---
output: html_document
---

# Exploratory Data Analysis

Alright, let's start digging into the data! Whenever you are handed a new data set, you want to read in the data so you can view it in RStudio and perform an Exploratory Data Analysis (EDA). 

## Reading in the data

You can read in your data using `read_csv()` and create a variable named `us_sent` that refers to the dataset.

```{r read in data, message = FALSE}
us_sent <- read_csv("data/cleaned_data_renamed.csv")
```

To view the data in a new tab within RStudio, you can use the `View()` function. Because this is an interactive RStudio function that doesn't work when we knit the document, we have set up our document so that the code can be viewed below but not actually run when we knit (specifically, we used the code chunk option `eval = FALSE`). 

```{r view data, eval = FALSE}
View(us_sent)
```

## Data structure and contents

As you may remember, in a tidy data set, each row is an observation, each column is a variable, and each cell is a value. In the case of the federal criminal sentencing data, each row represents an individual who was sentenced in the federal district court system in the U.S. in one of the country's 94 districts.

When we start exploring a data set, we will want to think about some key questions using the four W's: who, what, when, and where. Specifically, you might ask in the context of this study: who is in our data set? What was the sentence? When was the individual was sentenced? Where did the sentence occur? 

Can you guess which variables pertain to each question? Let's inspect our variables, which are in the columns, and see if that helps. There are several functions we can use to do this:

* `names()` will provide the names of the columns in the data set

    ```{r check column names}
    names(us_sent)
    ```
    
* `summary()` will provide the names of the columns in the data set along with a brief numeric or qualitative summary of each variable

    ```{r check column summaries}
    summary(us_sent)
    ```

* `str()` will display (sometimes complex) details of the internal structure of the R object, including the table dimensions, variable names, variable types, and the first 10 observations for each variable within a data table

    ```{r check object structure}
    str(us_sent)
    ```
    
* `glimpse()` is a simplified version of `str()` that only displays the dimensions, variable names, variable types, and the first set of observations for each variable within a data table (how many observations depends on the width of your output)

    ```{r get glimpse of data}
    glimpse(us_sent)
    ```
    
> Note: You can use the built in R help documentation to learn more about each function by typing a question mark followed by the name of the function in the console, e.g. `?str()` 


## Types of variables

What is halfway between 0 and 1? It is 1/2. What is halfway between horse and dog? There is no such thing! Thinking about each type of data is very important so that we don't code silly things like the mean of animal species.

There are two main types of data: **categorical data** and **numerical data**. Some examples of categorical data would be color, ethnicity, employment status, or states/countries. These have unique values, like California or Oregon. In other words, categorical variables take on discrete, finite values. In R, these variables might show up as characters (`chr`), `TRUE` or `FALSE` statements which are called logical vectors (`lgl`), coded as the integers (`int`), or factors (`fct`).

On the other hand, numerical data is in number form. Some examples of numerical data are temperature, height, and salary. It makes perfect sense to be 165.8 cm tall or for the temperature to be 82.4 degrees outside. In R, these variables might show up as doubles (`dbl`) or integers (`int`). 

There are some confusing data types that use numbers to *represent* categorical data, like zip code. You may live in the zip code 90201, which is a number, but you can't live in the zip code 90210.3. Only whole numbers, and specific ones at that, make sense here. We will learn more about using numbers to represent categorical data in this lesson.

Finally, dates and times are special variables that are treated differently depending on the context and structure of the values. In some cases, especially when there are few discrete values, dates and times might be treated as categorical variables. In some formats and in other cases, dates and times might be treated as numerical variables (note: even though a date or time might be represented as a number, this is not the type of numerical variable where it makes sense to do math in the typical way!). When data are specific dates (with day, month, and year) and/or times (with hours, minutes, seconds), then R has special data types that capture dates and times along a continuum. We don't need to worry about that for this case study, though!

**Can you identify which data type each variable in the federal criminal sentencing data is?**

You may notice that some variables' data types are not what you would expect. Oftentimes, R will automatically assign data types to variables in ways you don't want.  

Let's take the variable `sex`, for example. Remember that `sex` has been coded as a binary variable 0 and 1, where 0 is "Male" and 1 is "Female". We can confirm this using `distinct()`, a function that displays all unique values under a specified column. 

```{r}
us_sent %>%
  distinct(sex)
```

We can also see that `sex` is currently classified as a `dbl` above. Let's change that to the `fct` data type so R recognizes the variable as categorical. To deal with this, we can change the data types of variables using two important functions: `mutate()` and `factor()`.

You can think of `mutate()` as being a function that essentially replaces the a column in the data set with a new one. In this case, we are replacing the `sex` variable column that is coded as `dbl` with a new column for `sex` coded as `fct`. We can use the function `factor()` to specify the two levels of `sex`, 0 and 1, and labeling each level as "Male" and "Female" respectively. Using this process, we are telling R to consider `sex` to be a categorical variable with two levels. 


```{r}
us_sent <- us_sent %>% 
  mutate(sex = factor(sex, levels = c(0, 1), labels = c("Male", "Female")))
```

Let's check our work by using `glimpse()` again:

```{r}
glimpse(us_sent)
```

Great! It worked. `sex` is now of the `fct` data type. Now we can use this process to change the rest of the variables with incorrect data types. You can see that we don't always need to add labels, we just do that when we think it might be useful. Also notice we are treating `year` as a categorical variable for our analyses.

```{r}
us_sent <- us_sent %>% 
  mutate(educ = factor(educ, levels = c(1, 3, 5, 6),
                       labels = c("Less than HS", 
                                  "HS Grad", 
                                  "Some College", 
                                  "College Grad")),
         year = factor(year),
         criminal_history = factor(criminal_history),
         guilty_plea = factor(guilty_plea))
```

Now that our variable data types are sorted out, let's change one final component of our data set. Let's capitalize each category of the `race` variable using `str_to_title()`. Then we can use `fct_recode()` to turn `race` into a factor while also changing the "Other" level to "ARI", which stands for "another racial identity", to clarify what we mean. 

```{r}
us_sent <- us_sent %>% 
  mutate(race =  str_to_title(race),
         race = fct_recode(race, "ARI" = "Other"))
```

You can use `View(us_sent)` again to take a look at all the alterations we made to the dataset. 

Now that we have our data types sorted out, we can start exploring the data!

## How to visualize relationships

A good practice to do with a new data set is to explore it through visualization---we can get a sense of the distributions of the different variables and look at the relationships among variables. We will walk through a few graphs in R so you can see how to plot. We will examine each of these so we can see relationships and learn more about our data. Then, explore on your own by modifying this code!


### Two numerical variables

In this first plot, we will look at numerical variables only using a scatter plot. Scatter plots help us to visualize and understand numerical data better. We will compare each defendant's age to their sentence length through visualization and observation, and we will use this scatter plot to identify any patterns that exist in our data set. Each dot in the scatter plot we produce with the `ggplot()` command from the **ggplot2** package represents a row in our `us_sent` data. 

To use `ggplot()`, we start by indicating the data set we want to plot: `us_sent`. Then, we specify what our variables of interest are---in this case, we are interested in `age` and `sentence_length`. `geom_point()` specifies that we want to use a scatter plot to represent our data. There are also many fun and useful modifications that change the way a scatter plot looks. For example, you can change the color of data points using `color`, you can change the size of data points using `size`, and you can specify the transparency of data points using `alpha`. It's also good practice to come up with a useful title and good axis labels using the `labs` command.

```{r sentence length by age, fig.width = 6, fig.height = 6}
ggplot(us_sent, aes(x = age, 
                    y = sentence_length)) + 
  geom_point(color = 'coral2',
             size = 0.5,
             alpha = 0.4) +
  labs(title = "Sentence Length by Age",
       x = "Age (Years)",
       y = "Sentence Length (Months)")
```

What do you notice in this scatter plot? What do you wonder?


### One numerical and one categorical variable

We just created a scatter plot with two numerical variables. Now we will see what happens if one variable is numerical and the other is categorical. Run the code below that plots `criminal_history` (a categorical variable) against `age` (a numerical variable).

```{r criminal history by age, fig.width = 6, fig.height = 6}
ggplot(us_sent, aes(x = criminal_history, 
                    y = age)) + 
  geom_point(color = 'coral2', 
             alpha = 0.7) +
  labs(title = "Age by Criminal History Level",
       x = "Criminal History (1-6 levels)",
       y = "Age (Years)")
```

You might think it's a little difficult to see any clear patters when using a scatterplot to examine one quantitative and one categorical variable because the points are so densely packed together. Another helpful plot for this combination of variables is the side-by-side boxplot. You can create a side-by-side boxplot by simply switching out `geom_point()` with `geom_boxplot()` in the code above:

```{r, fig.width = 6, fig.height = 6}
ggplot(us_sent, aes(x = criminal_history, 
                    y = age)) + 
  geom_boxplot(color = 'coral2', 
             alpha = 0.7) +
  labs(title = "Age by Criminal History Level",
       x = "Criminal History (1-6 levels)",
       y = "Age (Years)") 
```

> Interpreting box plots: The middle horizontal line on a box plot refers to the mean of the data points. The botton and top lines of the box represent the lower quartile and upper quartile respectively (meaning the lower 25% of the data points are below the lower quartile and the upper 25% of the data points are above the upper quartile). The verticle lines called "whiskers" extending from the box represent the rest of the data, which includes all points outside of the middle 50% of the data points, excluding any outliers. Lastly, any points outside of the box and "whiskers" are outliers. 

What do you notice in this side-by-side boxplot? What do you wonder?

### Two categorical variables

Let's try one more scenario. What happens when you try to plot two categorical variables against each other? Run the code below to plot sex against race (both categorical variables).

```{r race by sex, fig.width = 6, fig.height = 6}
ggplot(us_sent, aes(x = race,
                    y = sex)) + 
  geom_point(color = 'coral2', 
             alpha = 0.7) +
  labs(title = "Race by Sex",
       x = "Race",
       y = "Sex (Male or Female)")
```

As you may have noted, scatter plots of two categorical variables are not that useful for analysis and inference since they only display the way we've grouped our data and not any of the underlying patterns. To compare two categorical variables frequency tables (shown below) or bar graphs are a better visualization to use. 

```{r}
us_sent %>% 
  count(sex, race, sort = TRUE)
```


In the remainder of this lesson we will focus on comparisons where we have *at least one numerical variable*.


## EDA of federal criminal sentencing data

<!-- - explain the different columns (linking to the background) -->
Now, let's return to exploring the variables of interest. Remember, we want to know *who* is in our data set, *what* the sentence was, *when* the individual was sentenced and *where* the sentence occurred. Did you identify how our variables might correspond with each of these questions? 

You might have classified the variables as follows: 

<!-- https://www.nature.com/articles/s41599-023-01879-5 -->

| Who | What| When | Where |
|:---|:---|:---|:---|
| `age` | `sentence_length` | `year` | `district` |
| `sex` | `mandatory_min` | | |
| `educ` | |||
| `race` | |||
| `criminal_history` | |||
| `guilty_plea` | |||

Let's start exploring the variables that fall under each of these key questions.

### Who?

#### Sex

Let's use `ggplot()` again to view the distribution of `sex` within our data set, this time using `geom_bar()` to display the data in a bar graph. Another difference from when we made a scatter plot above using `geom_point()` is that we are adding `fill` to make sure the bars in the bar graph are colored in. We can also add `scale_fill_viridis_d()` to automatically apply a certain color scheme to our plot.

```{r sex of sentenced individuals, fig.width = 5, fig.height = 5}
us_sent %>%
  ggplot() +
  geom_bar(aes(x = sex, fill = sex)) +
  labs(title = "Sex of Sentenced Individuals",
       x = "Sex",
       y = "Number of Individuals",
       fill = "Sex") +
  scale_fill_viridis_d()
```

From this graph, we can see that there are far more males than females in our data set. 

#### Race

Let's continue exploring through turning toward the `race` variable. We will start our exploration of `race` by using `distinct` to remind ourselves of the levels of the `race` variable.

```{r}
us_sent %>%
  distinct(race)
```

We can once again use `ggplot()` to make a bar graph displaying the `race` variable. We can make use of `fct_infreq()` when choosing `race` as our x variable, which makes sure the bars in the plot are ordered largest to smallest from left to right. 

```{r race of sentenced individuals, fig.width = 5, fig.height = 5}
us_sent %>%
  ggplot() +
  geom_bar(aes(x = fct_infreq(race), fill = race)) +
  labs(x = "Race",
       title = "Race of Sentenced Individuals",
       y = "Number of Individuals",
       fill = "Race") +
  scale_fill_viridis_d()
```

#### Race and sex

Now let's look at how `race` and `sex` relate to one another. First, let's look at the number of people in each combination using `count` again. 

```{r}
us_sent %>%
  count(race, sex)
```

We can represent these two variables using a bar graph. Once again we will use `ggplot` to create this plot. This time, since we are creating a bar graph displaying two different variables, we can define `race` as the x variable and have the colors of the bar graph correspond to the `sex` variable. 

```{r, , fig.width = 5, fig.height = 5}
us_sent %>%
  ggplot() +
  geom_bar(aes(x = fct_infreq(race), fill = sex)) +
  labs(x = "Race",
       title = "Race and Sex of Sentenced Individuals",
       y = "Number of Individuals",
       fill = "Sex")  +
  scale_fill_viridis_d()
```

We can also create a proportional bar plot. All we need to add to our previous `ggplot()` is `position = "fill"` within `geom_bar()`. 

```{r, fig.width = 5, fig.height = 5}
us_sent %>%
  ggplot() +
  geom_bar(aes(x = fct_infreq(race), fill = sex), position = "fill") +
  labs(x = "Race",
       title = "Race and Sex of Sentenced Individuals",
       y = "Number of Individuals",
       fill = "Sex")  +
  scale_fill_viridis_d()
```

#### Age

We might want to explore what the age of different individuals is across districts. Let's explore the districts of Maine, Rhode Island, and Vermont. We can use the `filter` command to look at only these three districts of interest, and then make a bar graph like before. 

```{r}
us_sent %>%
  filter(district %in% c("Maine", "Rhode Island", "Vermont")) %>%  
  ggplot() +
  geom_bar(aes(x = age, fill = district)) +
  labs(title = "Age in Maine, Rhode Island, and Vermont",
       x = "Age",
       y = "Count")
```

What do you notice about the ages represented in our data? Can you try plotting the ages for other districts to see how they differ from the three we've chosen for this plot?

<!--
Note from original authors: 
**To add**:
- what do we divide by?
- You may look at this plot and say that whites are sentenced at the federal district court more than black individuals. This is where it is important to look at the population in each district.

**Future Directions**

Bringing in the spatial district files

- https://www.openicpsr.org/openicpsr/project/100069/version/V1/view
- Downloading census data from the API.
- Joining to census data
- Limitations of census data
- Other potential things to mention (the affect of aggregation and spatial scale). -->


### What?

Now that we explored the "Who?" question about our data, let's move on to answering the "What?" question. You know that `sentence_length` and `mandatory_min` are the variables that fall under this category. 

#### Sentence length

<!-- Note from original authors: How do sentence lengths relate to policy? -- insert blurb here? -->

To better understand `sentence_length`, we’ll display a histogram for this quantitative variable. A histogram gives us a visual representation of the frequency of values. With R, we can change the width of each bin or choose a number of bins, and then the plot shows us how many sentences fell within each bin range. We can also use `geom_vline()` to add some red lines on the graph as a guide to think about common sentence lengths of 12, 60, 120, or 240 months. 


```{r, fig.width = 6, fig.height = 5}
ggplot(us_sent) +
  geom_histogram(aes(x = sentence_length), 
                 binwidth = 12) +
  geom_vline(aes(xintercept = 12), 
             color = "red", 
             linetype = 2) +
  geom_vline(aes(xintercept = 60), 
             color = "red", 
             linetype = 2) +
  geom_vline(aes(xintercept = 120), 
             color = "red", 
             linetype = 2) +
  geom_vline(aes(xintercept = 240), 
             color = "red", 
             linetype = 2) +
  labs(x = "Sentence Length (Months)", 
       y = "Number of Individuals",
       title = "Numbers of Individuals per Sentence Length")
```

What do you notice about the number of individuals per sentence length in our data set?

While it may be useful to look at how sentence length in terms of months, we can also adjust the scale of our historgram to look at sentence length in terms of years. We can do so by simply dividing our x variable, `sentence_length` by 12. We can also adjust our guiding red lines to examine the sentence lengths between 1, 5, 10, and 20 years:

```{r, fig.width = 6, fig.height = 5}
ggplot(us_sent) +
  geom_histogram(aes(x = sentence_length/12), 
                 binwidth = 1) +
  labs(x = "Sentence length in years", 
       y = "Number of individuals") +
  geom_vline(aes(xintercept = 1), 
             color = "red", 
             linetype = 2) +
  geom_vline(aes(xintercept = 5), 
             color = "red", 
             linetype = 2) +
  geom_vline(aes(xintercept = 10), 
             color = "red", 
             linetype = 2) +
  geom_vline(aes(xintercept = 20), 
             color = "red", 
             linetype = 2) +
  labs(title = "Distribution of Number of Individuals by Sentence Length in Years",
       x = "Sentence Length (Years)", 
       y = "Number of Individuals")
```

We observe a high frequency over 0, meaning that many individuals who are convicted may in fact receive a sentence of 0 months. At the other extreme, we see cases corresponding to 470 months, representing individuals who either have been given a long sentence, meaning 39 years or possibly a life sentence.

<!-- [could further discuss skew, peaks and relate to sentencing table, etc.] -->

#### How does sentence length relate to criminal history level? {.tabset}

<!-- Add boxplot and describe violin and ridge plots -->

##### Boxplot

##### Violin plot

Violin plots are another useful way of showing the distribution data. Let's use a violin plot to compare `criminal_history` and `sentence_length`. We can make use of the `geom_violin()` function to accomplish this:

```{r, fig.width = 6, fig.height = 5}
ggplot(us_sent) +
  geom_violin(aes(x = criminal_history, 
                  y = sentence_length, 
                  fill = criminal_history)) +
  labs(fill = "Criminal History", 
       y = "Sentence Length (Months)", 
       x = "Criminal History",
       title = "Sentence Length by Criminal History")

```

##### Ridge plot

Apart from historgrams and violin plots, ridge plots are another useful way to represent data. We can use similar code as for the violin plots but make use of `geom_density_ridges()`. We can also continue to add some guiding lines to our plots at 12, 60, 120, 180, and 240 months:

```{r, fig.width = 6, fig.height = 5, message = FALSE}
ggplot(us_sent) +
  geom_density_ridges(aes(y = criminal_history,
                          x = sentence_length,
                          fill = criminal_history)) +
  geom_vline(aes(xintercept = 12), 
             color = "black", 
             linetype = 2) +
  geom_vline(aes(xintercept = 60), 
             color = "black", 
             linetype = 2) +
  geom_vline(aes(xintercept = 120), 
             color = "black", 
             linetype = 2) +
  geom_vline(aes(xintercept = 180), 
             color = "black", 
             linetype = 2) +
  geom_vline(aes(xintercept = 240), 
             color = "black", 
             linetype = 2) +
  labs(title = "Distribution of sentence length in months by criminal history",
       subtitle = "Black dashed lines indicate 1, 5, 10, 15, and 20 year sentences",
       fill = "Criminal History",
       x = "Sentence length in months",
       y = "Criminal History") +
  scale_fill_viridis_d()

```

#### How does sentence length vary by adjusted offense level and criminal history?

Now that we understand some useful plots for examining our data. Let's return to using scatterplots to examine three important variables related to the "What?" question: `all_adjustments`, `sentence_length`, `criminal_history`. We can look at these three variables at once by comparing `all_adjustments` and `sentence_length` in a conventional way with scatterplots, but adding in `criminal_history` through color. 

```{r, fig.width = 6, fig.height = 5}
ggplot(us_sent) +
  geom_point(aes(y = sentence_length,
                 x = all_adjustments, 
                 color = criminal_history),
             alpha = 0.3) +
  labs(x = "All Adjustments",
       y = "Sentence Length (in months)",
       title = "Sentence Length by All Adjustments and Criminal History Level",
       color = "Criminal History") +
  scale_color_viridis_d()
```

Now we can display a lot of information in a single plot! However, let's try going a step further, and adding the `race` variable into the mix. We can do so by using the same code as for the previous plot, but also using the `facet_wrap()` function with `race` to create four different plots according to `race`.

```{r, fig.width = 7, fig.height = 6}
ggplot(us_sent) +
  geom_point(aes(y = sentence_length,
                 x = all_adjustments, 
                 color = criminal_history), 
             alpha = 0.3) +
  labs(x = "All Adjustments",
       y = "Sentence length (Months)",
       color = "Criminal History") +
  facet_wrap(~ race) +
  scale_color_viridis_d()
```

Now we have four different variables represented in a single plot, which is a super powerful tool. What do you notice about the plots above? 

<!-- #### How does the age range vary with criminal history? -->

```{r, , fig.width = 6, fig.height = 5, eval = FALSE, include = FALSE}
ggplot(us_sent) +
  geom_density_ridges(aes(y = as.factor(criminal_history),
                          x = age,
                          fill = as.factor(criminal_history))) +
  labs(fill = "Criminal History",
       x = "Age of individual in years",
       y = "Criminal History")
```

### When?

Let's turn to the final question we are asking about our dataset, which is encompassed in the "When?" question. Specifically, let's explore the time data found in our US sentencing data set. How many columns of data did we have again? Which tool can we use to find out? Do we remember?


We can use the `names()` routine to remind ourselves.


```{r check the columns, i.e. names}
names(us_sent)
```

We can see the fifteen column names in that output. Awesome. It looks like our time data, as far as "when" these convicted individuals in our data were convicted, is in the `year` column. Let's see what we're working with here by using `distinct()` again.

```{r Segregate and list the data in the column year}
us_sent %>% 
  distinct(year)
```

Excellent. So we know we have years from 2006 to 2020 in our data, or 15 rows worth of data.  It is worth noticing that although 2020-2006 = 14, when we count each year as a whole year of data *inclusively*, we have 15 distinct instances, which the distinct command helpfully listed out for us.

<!-- Now, each of these data points is a numeric variable, such as '2010', or '2015'. One way we could check is to use the `sapply()` routine again.

```{r}
sapply(us_sent, is.numeric)
```

In the output we can indeed see `TRUE` for the column `year`. As we progress in our educational journey, we will learn about different numeric variables, including double precision floating point arithmetic numeric variables. Is our `year` data in this format? Let's use the same command with a different argument:


```{r use sapply() to verify the year data is indeed numero}
sapply(us_sent, is.double)
```

Nice, we can see that our `year` data is indeed a double precision floating point number. -->

Let's do a graph of our `year` data, where we have each year on the vertical y axis and the sentences on the horizontal x axis.  

```{r year data bar chart, fig.width = 6, fig.height = 5}
ggplot(us_sent) +
  geom_bar(aes(y = year),
           fill = "blue") +
  labs(title = "Observations by Year",
       x = "Count",
       y = "Year")
```


Let's explore how `sentence_length` varies by each year in our data set. We can do this by using side-by-side boxplots again. 

```{r graph our year data- scatter plot, fig.width = 6, fig.height = 5}
ggplot(us_sent, aes(x = year, 
                    y = sentence_length)) + 
  geom_boxplot() +
  labs(title = "Sentence Length by Year",
       x = "Sentence Length",
       y = "Year")
```
<!-- could include more information on interpreting boxplots, explaining what outliers are, etc. would likely write about this above where we first introduce boxplots. We could also consider adding in information about examining center, spread, etc. -->

### Where {.tabset}

Now that we've explored the "who?", "what?", and "when?" questions about our data set, let's finish off our EDA by understanding the "where?" question. Let's check what districts we have in the data. We can do this using `distinct()` again.

```{r}
us_sent %>%
  distinct(district)
```

You'll notice that certain states are a single district on their own. Other larger states are split into several districts (e.g. New York East, New York North).  

If you live in the United States, do you know which district you live in?

If not, you can look it up at [the United States Department of Justice's website](https://www.uscourts.gov/federal-court-finder/search).

Apart from using the `distinct` variable to figure out what districts we have in our data set,  we are also interested in finding out how many sentences were made in each district. We also will want to think about this question in relation to the population of those districts, which can be quite nuanced and we will come back to this later.

Our goals in this next section are to think about ways we can explore the question "Where did those sentences occur?" in a visual way.

<!--Note from original authors: **Learning aims**

- introduce factors as a data type (accomplished above)
- explain why it might be better to put our names on the y axis instead of the x-axis for many categories and those with longer names. This makes it more readable.
- explain that automatically categorical data will be placed in alphabetical order.
- we can reconfigure the graph using functions from the `forcats` package.
- This is a good example for when you might want to order it in terms of frequency (i.e. the count) using `fct_infreq`
- We may also want to reverse the order to see the districts which have the most sentences at the top of our plot using `fct_rev`. -->

Let's start looking at the number of individual sentences across districts by using a bar plot. 


```{r, fig.width = 6, fig.height = 5}
ggplot(us_sent) +
  geom_bar(aes(x = district))
```

We can see immediately that, given the large number of districts, a simple bar graph makes it super hard to interpret the data. Let's go through some ways we can improve this plot. 

#### 1. Place district on the $y$-axis

First, we can change our plot so that `district` is on the y-axis so there is more room for the text, and let's not worry about presenting accurate axis labels or titles until we get our plot into a readable format: 

```{r, fig.width = 5, fig.height = 9}
ggplot(us_sent) +
  geom_bar(aes(y = district))
```

That definitely makes it easier to read the district names! However, we can think about ordering the districts in such a way that is useful for us. For example, we might be interested in seeing the districts with the most amount of sentences.

#### 2. Sort district by frequency

To answer this question, we can use `fct_infreq()`, as we did earlier in our EDA, to order the districts from the least to the most number of sentences. 

```{r, fig.width = 5, fig.height = 9}
ggplot(us_sent) +
  geom_bar(aes(y = fct_infreq(district)))
```

#### 3. Reverse the order of the districts

Alternatively, we can order the districts from the most to the least amount of sentences in our data set by using `fct_rev()` in conjunction with `fct_infreq()`.

```{r, fig.width = 5, fig.height = 9}
ggplot(us_sent) +
  geom_bar(aes(y = fct_rev(fct_infreq(district))))
```

#### 4. Add title and axes labels

Now that we have our plot data organized in a readable and useful way, let's add useful title and axis titles. When we have longer titles, you can use $\n$ to add a line break. 

```{r, fig.width = 5, fig.height = 9}
ggplot(us_sent) +
  geom_bar(aes(y = fct_rev(fct_infreq(district))),
           fill = "forestgreen") +
  labs(title = "Number of Individuals Sentenced at \nthe Federal District Court Level",
       y = "Federal District Court",
       x = "Number of individuals")
```

<!--##### Making the plot more readable with subsetting -->

```{r, include = FALSE, eval = FALSE}
ggplot(us_sent) +
  geom_bar(aes(y = fct_rev(fct_infreq(district)))) +
  labs(title = "Number of individuals sentenced at the federal district court level for each district from x to x",
       y = "Federal District Court",
       x = "Number of individuals")
```

```{r, include = FALSE, eval = FALSE}
ggplot(us_sent) +
  geom_bar(aes(y = fct_infreq(district))) +
  labs(title = "Number of individuals sentenced at the federal district court level for each district from x to x",
       y = "Federal District Court",
       x = "Number of individuals")
```

<!--##### Exploring the census data

**To Do**:

- If we want to get out the district populations, we will probably need to download the data by the county level.
- Decision points: we could download the data in categories by age and sex and race: e.g. 5-9, 10-14 etc. This might get a little -->

```{r census-data-import, echo = TRUE, warning = FALSE, message = FALSE, results = 'hide', include = FALSE, eval = FALSE}

# apply unique census api key
census_api_key("5177724b01a7fe4714097e711cb95230c37cfce7", overwrite = TRUE)

# import census data
## guide to spatial units: https://api.census.gov/data/2016/acs/acs5/geography.html
## variable of interest -> population
## vars <- load_variables(year = 2013,
                      # data set = "acs5",
                      # cache = TRUE)

# B02001_001: Total
# B03002_003: White alone (Not Hispanic or Latino)
# B03002_004 Black or African American alone (Not Hispanic or Latino)
# B03002_012: Hispanic or Latino
# B03002_005: Native American alone (Not Hispanic or Latino)
# B03002_006: Asian alone (Not Hispanic or Latino)
# B03002_007: Native Hawaiian or Pacific Islander alone (Not Hispanic or Latino)
# B03002_009: Multiple Races (Not Hispanic or Latino)
# B03002_008: Other (Not Hispanic or Latino)

#census_place_df <- get_acs(geography = "state", variables = c("B01003_001E"), geometry = TRUE, year = 2010)

```

